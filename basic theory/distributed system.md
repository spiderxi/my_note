# 简介
## 网络问题
_什么是网络分区问题?_
```
网络出现多个分区, 分区内的节点正常通信, 分区之间无法正常通信

🌙 例如: 跨地域机房之间网络故障, 机房之间机器可以正常通信
```

_网络通信时存在的问题有哪些?_
```
🌟 可能会重排序报文
🌟 可能会重复发送报文
🌟 可能会丢失报文
🌟 可能修改报文

🌙 重排问题可以通过编号解决, 重复发送问题需要通过幂等手段解决, 修改报文问题通过TSL协议解决
🌙 丢失报文问题工程上假设可以通过有限次重试可以解决(假设大部分情况下网络是准时的, TCP实现方案)
🌙 涉及网络通信(RPC等)时, 一定要考虑时序, 幂等, 超时问题!!!
```

# 分布式数据库

## 1. 分片

_哈希分片相较于范围分片的优点?_

```
🌟 哈希分片: 各个节点的数据更均匀
🌟 范围分片: 支持范围查询
```

_一致性哈希算法有什么优点?_

```
普通的hash算法将key直接映射为节点(key -> 节点), 一致性哈希函数将key先映射为slot, slot再对应节点, slot数量不变(key -> slot -> 节点)

🌙 优点: 节点增加/减少时, 一致性hash由于slot数量不变只要迁移部分slot(变动节点的slot)的数据, 普通hash算法需要迁移几乎所有节点的数据
```

## 2. 复制

_为什么要复制数据?_
```
提高可用性(A)和分区容错性(P)

🌙 复制会导致数据一致性(C)降低
```

_主从节点之间数据的复制方式分为哪三种?_

```
🌟同步复制: 主节点等待所有从节点写入完成才响应客户端写入成功(数据一致性最高)
🌟异步复制(最常用): 主节点写入完成后直接响应客户端, 稍后再将数据写入到从节点(数据一致性最低)
🌟半同步复制: 主节点等待部分从节点写入完成就可以响应客户端写入成功
```

_主从节点时主/从节点出现故障会发生什么?_
```
🌟 主节点故障: 通过共识算法选举出一个从节点作为新的主节点
🌟 从节点故障: 从节点恢复后重新连接主节点, 进行全量/增量数据同步
```

_什么是脑裂?_
```
主从架构中, 网络分区时从节点认为主节点宕机, 从而产生两个主节点
```

_讲一下Quorum数据冗余机制?_

```
在N个节点的集群中, 假设每次至少写入W个节点, 每次读至少从R个节点读, 那么需要满足:
W + R > N
```


_讲一下分布式系统的一致性强弱等级?_

```
一致性从强到弱分别为:
1️⃣线性一致性(linearizability)
所有客户端的读写操作会被放到同一个FIFO执行队列中像单机一样执行, 并发操作之间顺序可交换

2️⃣顺序一致性(sequential consistency)
每个客户端的读写操作会被放入到各自的FIFO执行队列中像单机一样执行

3️⃣因果一致性(happens-before)
有因果关系的操作需要先后在分布式系统中像单机一样执行, 其他操作可以乱序执行

4️⃣最终一致性(eventual consistency)
可能从分布式系统中部分节点读到旧数据, 但最终读到的数据是最新的
```

## 3. 分布式理论
_如何证明 CAP 理论?_
```
反证: 假设存在CAP三者满足的分布式系统, 由于有分区容错性可以出现网络分区, 当出现网络分区时向一个分区写入X新值, 从另一个分区读X, 必然出现不一致
```

_什么是FLP不可能定理?_
```
在异步通信的分布式系统中，即使只存在一个进程故障，也不存在任何算法能保证所有非故障进程最终达成一致。

🌙 异步通信=发送微信消息(不知道对方啥时候能看到/有没有看到)
🌙 同步通信=打电话(对方能明确挂断或接听)
🌙 半同步=带截止时间的微信消息("7点前不回复我就先吃饭了")
🌙 在工程应用中, 我们必须假设网络在大多数时间是可靠的, 在半同步的环境下实现分布式一致
```

# 分布式一致性协议(共识算法)
_分布式一致性协议有哪些?_
```
🌟 Paxos
🌟 Raft
两个算法实现逻辑不易理解(不知道为什么这么设计), 这里略过

🌙 Raft算法更容易理解, 应用更广
🌙 Raft算法大致思想就是选举出一个Leader节点, 一切以Leader节点为准, 一个epoch只有一个Leader
🌙 只需要记住, Raft算法在半数以下节点宕机时, 能保持集群达成一致共识
```

# 分布式事务

_单机数据库如何解决事务的原子性问题?_
```
Write Ahead Log (WAL)思想：先写回滚日志，再写数据(数据冲突时可以通过日志回滚)

🌙 写日志的过程本身通过磁盘原子写入保证原子性, 一般磁盘可以保证原子写入一个块(大小为512KB)
```

_分布式事务的应用场景有哪些?_
```
🌟 微服务场景: 假设订单和账户是两个服务, 那么订单结算和扣款两个操作必须保证原子性
🌟 分片数据库场景: MySQL分片, 账户余额表水平分表到两个节点, 转账时需要保证扣钱和加钱两个操作原子
```

_什么是2PC算法?_
```
2PC为两阶段提交算法, 通过一个额外事务管理器协调节点之前的事务, 分为两个阶段
1️⃣第一阶段(prepare): 事务管理器告诉每个节点锁定资源, 节点返回资源锁定结果
2️⃣第二阶段(commit): 事务管理器告诉每个节点是否提交(所有节点第一步成功时)或释放资源

🌙 2PC严格保证一致性, 需要在节点锁定资源后阻塞资源请求(不可读写), 直到明确提交或释放资源, 如果期间事务管理器故障或网络分区会导致长时间阻塞
```

_什么是XA?_
```
XA 协议是一套分布式事务的接口规范，定义了 TM（事务管理器）与 RM（资源管理器，如 MySQL、MQ 等）之间的交互标准, 基于XA接口可以实现2PC算法
```

_讲一下TCC(Try-Commit-Cancle)方案?_
```
微服务架构中的一种事务方案: 每个服务实现3种接口(try, confirm, cancle), try接口预订资源, confirm执行, cancle释放预留资源

🌙 TCC和业务代码耦合性强, 并且TM和RM都是微服务(可用性高)
🌙 互联网金融业务常常使用TCC, 以库存-扣款为例, try时锁定库存并冻结金额, confirm时扣除库存和金额, cancle的话则归还库存与金额
```

_TCC和2PC的区别在哪里?_
```
🌟 TCC是基于业务实现的, 2PC是在数据库层实现的
🌟 TCC是预留资源, 2PC是锁定资源(阻塞)

🌙 两个算法都用于短事务
```

_什么是Saga事务方案?_
```
将一个事务拆分成多个小事务, 如果某个小事务执行失败则对已执行的事务进行补充操作, 以库存->订单->支付为例, 事务的拆分为:
A=扣减库存 -> B=创建待支付订单 -> C=扣余额, 如果C事务失败则执行B事务和A事务的补偿操作 B'=订单为支付失败 A'=归还库存

🌙 saga事务方案适用于长活事务（Long Lived Transaction）
```

# 分布式系统时序
_单机情况下可以获取单调的时钟吗?_
```
可以, 例如Java使用System.nanoTime()可以获取JVM启动后的纳秒数

🌙 unix时间戳可能会有人为回拨时间/NTP服务器回拨时间的情况, 不一定单调
🌙 分布式系统中, 全局时钟在不同节点可能不一致导致无法判断事件的先后顺序, 只能通过逻辑时钟判断事件的因果关系
```

_什么是逻辑时钟?_

```
有因果关系的两个事件的逻辑时钟必然有序(逻辑时钟有序的两个事件不一定为因果关系)

🌟 单个进程发生一个事件时自己的逻辑时钟自增 C(A) = C(A)+1
🌟 进程A发送消息给进程B时如果C(B) = max(C(A), C(B)) + 1

🌙 工程应用中使用向量逻辑时钟, 每个进程i维护一个逻辑时钟向量V[i:], V[i, j]=第i个节点维护的j号节点的逻辑时钟数值
🌙 向量逻辑时钟可以保证写入的因果一致性(逻辑时钟向量作为数据版本号)
```

_分布式数据库生成快照时怎么保证数据一致性?_
```
Chandy-Lamport 算法, 原理: 单个节点生成快照后, 发送marker消息广播给其他节点并记录接受到的消息, 最后通过单个节点快照和记录的消息还原出最终快照

🌙 如果只记录所有节点的快照, 不记录这期间接受到的消息, 可能会导致数据不一致(系统是动态的, 但多个节点之间不可能瞬时记录快照)
```

# 参考资料
深入理解分布式系统 -唐伟志
