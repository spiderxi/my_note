# 1. 分布式数据库

## 1. 分片

_讲一下一致性 hash 算法, 有什么优点?_

```
c_hash()函数的值域形成一个哈希环(), 节点和记录通过chash()映射到环上一点(节点也可以映射到多个虚拟点上), 每条记录点找到顺时针最近的点对应的节点作为存储节点

优点: 节点数量变化时只需要在少量节点间进行数据迁移
```

_范围分片(Range Sharding)和哈希分片(Hash Sharding)的区别?_

```
* 哈希分片: 通过 c_hash(key)所在范围决定节点, 节点负载更均衡

* 范围分片: 通过key所在范围决定节点
```

_如何解决水平分表带来的统计问题和垂直分表带来的连接问题?_

## 2. 复制

_讲一下分布式系统的一致性模型?_

```
一致性从强到弱分别为:
1. 线性一致性(linearizability)
所有客户端的读写操作会被放到同一个FIFO执行队列中像单机一样执行, 并发操作之间顺序可交换

2. 顺序一致性(sequential consistency)
每个客户端的读写操作会被放入到各自的FIFO执行队列中像单机一样执行

3. 因果一致性(happens-before)
有因果关系的操作需要先后在分布式系统中像单机一样执行, 其他操作可以乱序执行


4. 最终一致性(eventual consistency)
可能从分布式系统中部分节点读到旧数据, 但最终读到的数据是最新的
```

_主从节点之间数据的复制方式分为哪三种?_

```
* 同步复制: 主节点等待所有从节点写入完成才响应客户端

* 异步复制(最常用): 主节点写入完成后直接响应客户端, 稍后再将数据写入到从节点

* 半同步复制: 主节点等待至少一个从节点写入完成就可以响应客户端
```

_多主多从时如何解决在多个主节点写入导致的数据冲突?_

```
* 将同一个记录的写请求路由到固定主节点来避免冲突

* Last Write Wins(LWW)

tip1: 多主多从时数据冲突解决起来很麻烦, 这种架构只用在多个主节点
```

_讲一下无主节点情况下的 Quorum 数据冗余机制?_

```
在N个无主节点的副本集群中, 假设每次写入至少需要W个节点成功, 每次读至少从R个节点读, 那么保证一致性需要满足:
W + R > N
```

## 3. 分布式理论

_数据库有哪些隔离级别, 对应级别能解决的并发问题是什么?_

```
读未提交: 可以读到未提交事务写入的数据
读已提交(RC): 只能读到已提交事务写入的数据,  解决脏读问题
可重复读(RR): 保证一个事务中两次读取相同记录的结果相同, 解决不可重复读问题
串行化: 事务之间串行执行, 解决幻读问题
```

_讲一下数据库事务需要满足的 ACID 属性?_

```
A: 原子性
C: 一致性 (数据约束没有被破坏)
I: 隔离性 (事务之间并发执行时一定程度上不受其他事务影响)
D: 持久性
```

_如何证明 CAP 理论?_

```
反证: 假设存在CAP三者满足的分布式系统, 由于有分区容错性可以出现网络分区, 当出现网络分区时向一个分区写入X新值, 从另一个分区读X, 必然出现不一致
```

_PACELC 理论的内容?_

```
* 当出现网络分区时分布式系统必须在CA之间权衡

* 当没有出现网络分区时分布式系统必须在一致性(C)和延迟(L)之间权衡
```

_哪些分布式系统属于两将军模型, 哪些属于拜占庭(Byzantine)模型?_

```
* 私有网络中的分布式系统属于两将军模型
网络会延迟和丢失, 节点会宕机和崩溃


* 公共网络中的属于Byzantine模型
节点除了宕机和崩溃, 还会恶意破坏系统
```

_什么是 FLP 不可能定理?_

```
一个分布式系统中, 如果无法判断一个节点没有及时响应的原因是网络延迟还是节点崩溃, 那么实现安全可靠的共识算法
```

# 2. 共识算法

## 1. Paxos

_讲一下 paxos 算法流程?_

```
1. Proposer向Acceptor发起Prepare请求, 提议号为<round++, nodeId>

2. 如果round为Acceptor见过的最大轮数时Acceptor会响应, 给予Proposer承诺"Accept阶段会投票给你", 如果Acceptor已经在Accept阶段响应过一个提议值v, 还需额外添加承诺内容"但你的提议值必须为v"

3. 如果Proposer在Prepare阶段获取超过半数的响应, 会发起Accept请求, 提议值为Acceptor承诺要求的值(如果没有要求则可以为任意值)

4. 如果Acceptor收到的Accept请求的轮数round仍然为它见过的最大值(Acceptor中途没有再给其他Proposer承诺), 则给予响应

5. Proposer在Accept阶段如果获得超过半数的响应, 则广播提议值给learner
```

_为什么 paxos 算法要分为两个阶段(2-phase), 为什么不让 proposer 一次性提出建议, 看看是否有大多数 Acceptor 投票来决定是否通过?_

```
* 如果proposer只能投一次票, 可能由于网络分区和节点故障导致平票

* 如果proposer能反复投票, 通过的多个建议之间可能会冲突
```

_paxos 算法会有什么问题, 如何解决?_

```
活锁(livelock)问题:
某些Acceptor在接收到Accept请求之前总是被另一个Proposer的Prepare争抢, 导致总是拒绝Accept请求

解决方法: 将Proposer提出建议的间隔设置为随机时间
```

## 2. Raft

_什么是复制状态机(Replicated State Machine)?_

_讲一下 Raft 算法中如何进行领导者选举?_

_Raft 算法中, Leader 如何处理写请求?_

_为什么 term timeout 时间[T, 2T]中的 T 应该大于网络传播时间?_

# 3. 分布式事务

_单机数据库如何实现事务的原子性问题?_

```
使用Write Ahead Log(WAL), 在写入磁盘前先写入日志, 例如Innodb执行事务时:

1. 修改buffer pool中的数据页
2. 将修改过程记录到内存中的redo log buffer中
3. 事务要提交时, 将redo log从内存刷新到磁盘, 状态为Commit Record, 此时事务提交成功
4. 定时将buffer pool中的脏数据页刷新到磁盘中, 刷新后将磁盘中的redo log状态标记为End Record

tip: 在数据库crash后的重启阶段, 会先执行redo log中状态为Commit Record的记录, 恢复内存中丢失的数据页
```

_什么是 2PC /3PC 算法, 有什么缺点?_

```
2PC为两阶段提交算法
1. 第一阶段(prepare)
所有participants执行子事务的内容后在提交前告诉coordinator自己能否提交子事务

2. 第二阶段(commit)
coordinator通知所有participants是提交事务还是回滚事务

缺点: 同步阻塞问题, 单点故障问题, 数据不一致问题
---------------------------------
3PC在2PC的两个阶段前新增了一个阶段, 用于询问各个子事务执行者是否准备就绪
```

_什么是 Saga 事务?_

```
将一个分布式事务分为多个子事务T1 T2 T3, 每个子事务有一个补偿事务C1 C2 C3, 当子事务执行失败时按栈的顺序执行已经完成的子事务的补偿事务

示例: 网购场景中, 子事务有: 库存-1, 创建订单, 支付;  对应的补偿事务为库存+1, 删除订单, 退款
```

_讲一下 TCC ?_

```
TCC (Try-Commit-Cancle): 每个服务实现3种接口(try, commit, cancle), try接口预订资源, commit执行子事务, cancle释放预留资源

* 互联网金融业务常常使用TCC
```

# 4. 时间

_哪个网络协议用于同步时间?_

```
NTP协议

协议核心思想: 通过客户端和服务端发送和接收网络包的时间戳计算网络延迟
```

_什么是逻辑时钟?_

```
逻辑时钟是描述分布式系统中因果关系的时间, 有因果关系的两个事件的逻辑时钟必然有序(逻辑时钟有序的两个事件不一定为因果关系)

* 每个进程新发生一个事件时进程的逻辑时钟C+1
* 进程A向进程B通信时如果C(A)+1 > C(B), 则更新C(B)
```

_什么是向量时钟?_

```
每个进程维护一个逻辑时钟向量V[i], V[i, j]为分布式系统中第i个节点维护的j号节点的逻辑时钟, 进程通信时会交互并更新向量

作用: 分布式数据库中用于检测数据冲突
```
