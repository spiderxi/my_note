# 1. 并发编程简介

## 基础理论

***并发和并行的区别?***
```
🌟 并发指一个时间段内多个任务同时进行, 但在任一时刻只有一个任务进行
🌟 并行指任意时刻有多个任务进行
```


***并发编程(线程安全)三大问题是什么?***
```
🌟 原子性: 操作要么全发生要么全不发生
🌟 可见性: 先进行的操作对后进行的操作可见
🌟 有序性: 单线程中会存在指令重排序, 在多线程下需要保证重排序不会改变语义

🌙 JVM中, 除long和douebl单次读写变量都是原子的
```

## 线程

***进程, 线程, 协程的区别?***
```
🌟 进程: 操作系统内存/CPU时间片等资源分配的基本单位
🌟 线程(Java中的Thread): 多个线程共享给进程分配的资源, 一个线程执行时拥有独立的栈和CPU核心
🌟 协程(Java中的Fiber): 多个协程共享线程的CPU核心, 协程调度通过应用程序实现

🌙 一次线程上下文切换约为10微秒, 一次协程切换时间0.1微秒
```

***为什么切换线程比切换进程快, 切换协程比线程快?***
```
🌟 切换时进程需要额外切换内存管理上下文(切换页表), TLB失效导致内存访问变慢

🌟 切换线程时需要进入操作系统内核态, 需要切换线程上下文(CPU寄存器)
```

***JVM的线程有哪些状态?***
```
🌟 NEW: 线程对象已创建，但尚未调用 start()
🌟 RUNNABLE: 已调用start()
🌟 BLOCKED: 因monitor锁被动阻塞状态, 如synchronized
🌟 WAITING / TIMED_WAITING: 主动阻塞等待被唤醒或等待超时, 如wait()/park()
🌟 TERMINATED: run()方法执行结束

🌙 线程池中的idle线程处于WAITING状态
```


## 锁
***什么是死锁?***
```
锁的等待链形成环导致环中每个线程/进程都永久阻塞
```

***死锁的四个必要条件是什么?***
```
🌟 锁互斥
🌟 锁不可剥夺
🌟 占有锁且等待锁
🌟 循环等待锁
```

***乐观锁和悲观锁的区别?***

```
🌟乐观锁读数据不加锁, 写数据时通过版本号判断是否冲突, 冲突需进行处理(重试/抛出异常)
🌟悲观锁读写数据过程中加互斥锁

🌙 悲观锁适合频繁发生并发冲突的场景
```

***公平锁和非公平锁的区别?***

```
🌟 公平锁: 先阻塞的线程先获得锁
🌟 非公平锁: 不论先后, 线程获取锁的机会相同
```

***可重入锁和非可重入锁的区别?***
```
对于可重入锁, 已经获取了锁的线程还可以再获取
```

# 2. Java并发编程

## 线程使用

***创建一个线程的方式有哪些?***

```
🌟 继承Thread类
🌟 使用Runnable构造Thread
```

***线程常用的API有什么?***
```
🌟 获取当前线程对象: Thread.currentThread();
🌟 主动进入TIMED_WAITING状态: Thread.sleep(1000);
🌟 设置线程竞争优先级: Thread#setPriority(Thread.MAX_PRIORITY);
```

***如何获取线程栈快照?***
```
使用JDK工具 jstack <pid>
```

***线程池的submit()和execute()的区别?***
```
submit()有返回值Future<?>, 不会吞掉异常, execute()无返回值且会吞掉异常

🌙 最佳实践: 无特殊需求一律使用submit(), execute()为JDK向下兼容设计
```

***一般来说一个JVM进程能同时启动多少个线程?***
```
线程数量和Memory和操作系统限制有关, 线上4GB内存一般线程数1k~5k

🌙 默认一个线程需要申请1MB栈空间, 所以4GB内存的理论线程数量上限为4096
```

## 线程协作

***Java中如何保证线程安全?***
```
使用synchronized/lock等锁, 和volatile等机制保障原子性, 可见性, 有序性
```

***Java中多线程协作的API有哪些?***

```
🌟 Object#wait() Object#notify() Object#notifyAll()
🌟 Thread#join() Thread.sleep()
🌟 synchronized Lock#lock()
```

## JMM

***讲一下Java Memory Model?***
```
JMM全称Java内存模型, JMM定义了并发编程下JVM需要遵循的抽象, 用于屏蔽底层硬件细节:
🌟 工作内存: 每个线程的私有缓存, 保存了该线程的数据副本, 对应硬件L1/L2缓存
🌟 主内存: 存储线程共享的数据, 对应Memory
🌟 volatile: 保证了对变量操作的可见性
🌟 synchornized: 保证了操作的原子性和可见性
```

## synchronized

***synchronized代码块锁的对象可以是什么?***
```
🌟 修饰静态方法时锁对象为Class对象
🌟 修饰成员方法时锁对象为 this
🌟 同步代码块中可以自己指定锁对象
```

***synchronized的原理是什么?***
```
synchronized等价于在同步代码块前后添加了两条字节码指令monitorEnter/monitorExit, 这两个指令获取对象头中的指针指向的ObjectMonitor对象, 进行锁操作

🌙 ObjectMonitor保存了竞争锁的线程集合, 当前持有线程和锁计数, 等待锁的线程集合
```

***synchronized锁升级过程是怎样的?***
```
JVM级别synchronized锁进行了优化, 可以理解为一个自适应算法, 根据实际锁冲突情况使用不同类型的锁优化性能:
无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

🌙 偏向锁: 记录锁偏向的线程, 单次CAS判断即可, 偏向线程不变则不需要切换线程上下文, 偏向线程改变则升级
🌙 轻量级锁: CAS自旋锁, 获取锁成功时不需要切换线程上下文, 获取锁冲突则锁升级
🌙 重量级锁: 强制切换线程上下文用于获取锁
🌙 JDK15+默认禁用了偏向锁
```

## volatile和CAS

***volatile实现原理?***
```
使用了内存屏障指令保证了对volatile变量的写入, 会立刻从工作内存刷新到主内存, 对volatile变量的读取, 会先从主内存中读取到工作内存
```


***CAS实现原理?***
```
CPU提供的硬件指令, 可以原子地进行compare and swap操作, 比较结果相同时则写入, 否则不做操作

🌙 早期CPU使用总线锁保证原子比较和写入, 但性能差
🌙 现代CPU在执行 CAS 时，通过对缓存行加锁（cache locking）来避免总线锁定
🌙 硬件层面通过MESI缓存一致性协议保证多核CPU之间的缓存一致, 从而为缓存行锁提供支持
```

***CAS的ABA问题如何解决?***
```
ABA问题无法确保数据在锁定期间被写入能保障数据和期望的一致, 使用版本号解决ABA问题
```


# 3. JUC

## Lock

***Lock和Synchronized的区别有哪些?***

```
🌟 Lock可以是公平锁,  Synchornized只能是非公平锁
🌟 Synchornized内部有异常会自动释放锁, Lock不会
🌟 Lock更灵活, 可以使用tryLock(), 即使获取不到锁也不会阻塞, 也可以使用Condition进行更细粒度的唤醒
```

## ThreadLocal

***讲一下ThreadLocal实现原理?***
```
get()方法调用时, 会获取当前线程对象绑定的ThreadLocalMap , map中的key是ThreadLocal对象的弱引用, 值是当前线程的副本值

🌙 使用弱引用的目的是便于ThreadLocal对象的回收
```


***使用ThreadLocal会有什么问题, 如何解决?***
```
使用线程池中的线程时, 如果忘记remove()会造成内存泄漏
```


## 线程池

***为什么需要使用线程池而不是直接创建线程实例?***
```
🌟 便于统一管理
🌟 资源池化思想, 避免频繁创建和销毁线程的开销
```

***JUC线程池相关抽象架构?***
```
🌟 Executor: 线程池顶级抽象, 定义了execute()方法
🌟 ExecutorService: 继承Executor, 异步编程线程池抽象
🌟 Future / CompletableFuture: 异步编程抽象
🌟 BlockingQueue: 阻塞队列抽象
🌟 Callable / Runnable: 任务抽象
```

***创建线程池ThreadPoolExecutor的参数有哪些?***

```
🌟 核心线程数
🌟 最大线程数
🌟 拒绝策略: 
🌟 阻塞队列
🌟 空闲线程存活时间
🌟 线程工厂
```

***线程池提交任务后的执行流程?***

```
1️⃣ 如果当前线程数 < 核心线程数, 新建线程并执行任务
2️⃣ 如果当前线程数 >= 核心线程数, 将任务放入阻塞队列
3️⃣ 如果最大线程数 >= 当前线程数 >= 核心线程数并且阻塞队列已满, 新建线程执行任务
4️⃣ 如果当前线程数 > 最大线程数, 执行拒绝策略

🌙 如果线程数 > 核心线程数 并且 idle时间 > 空闲线程存活时间, 线程会被销毁
🌙 需要结合业务合理地配置拒绝策略 (常见策略: 抛出异常 / 直接丢弃任务)
🌙 注意LinkedBlockingQueue阻塞队列的OOM风险
```

***如何设置线程池的核心线程数?***
```
🌟 针对IO密集型：核心线程数 = CPU核心数 * 2, 例如RPC调用/网络IO
🌟 针对计算密集型：核心线程数 = CPU核心数 + 1, 例如图像处理
```

***常见的阻塞队列有哪些?***

```
🌟 数组阻塞队列: ArrayBlockingQueue
🌟 链表阻塞队列: LinkedBlockingQueue
🌟 优先级阻塞队列: PriorityBlockingQueue
🌟 延迟阻塞队列: DelayQueue
```

## AQS

***讲一下AQS(AbstractQueuedSynchronizer)的内部实现?***
```
AQS是JUC中的一个核心同步器框架, 可以通过实现抽象方式实现自定义的同步器, 内部实现为:

AQS内部维护一个通过双向链表实现的FIFO队列和一个volatile int 的state变量, 加锁时通过CAS改变state变量, 如果获取锁失败会将线程插入队列

🌙 CountDownLatch, ReentrantLock都基于AQS实现
```

***如何使用AQS实现独占锁和共享锁, 如何基于AQS实现自己的锁控制?***
```
🌟 独占锁: 重写acquire和release方法, 独占锁CAS(0, 1)

🌟 共享锁: 重写acquireShared和releaseShared方法CAS(state+1, state)
```
