# 背包问题

dp[i][j]表示前i个物品在容积不超过j时的最大价值

```
01背包问题状态转移方程
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])

完全背包问题状态转移方程
dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i]] + value[i])
```

# 并查集

```java
public class UnionFindSet {
    private int[] father; // idx的集合代表元素为father[idx]
    private int[] height; // idx为根节点的树的高度为height[idx]
    public UnionFindSet(int n) {
        father = new int[n];
        height = new int[n];
        for (int i = 0; i < n; i++) father[i] = i;
    }
    public int find(int idx) { // 返回idx所在集合代表元素
        if (father[idx] == idx) return idx;
        return father[idx] = find(father[idx]); // 缩短路径并返回代表元素
    }
    public void union(int x, int y) {
        int xf = find(x), yf = find(y);
        if (xf == yf) return;
        if (height[xf] > height[yf]) {
            father[yf] = xf;
            return;
        }
        father[xf] = yf;
        if (height[xf] == height[yf]) height[yf]++;
    }
    public boolean isInSameUnion(int x, int y) {
        return find(x) == find(y);
    }
}
```


# 最短路径算法


## Dijstra算法

算法适合场景: 求单点到图中其他所有点的最短路径, **单个路径长度>0**

算法思想: 每次从**没有访问过的节点**中选出离源点距离最短A节点, 用 `A节点到B的出边长+ 源点到A点距离`更新 `源点到B点最短距离`.

Java代码

```java
public int[] dijstra(int[][] graph, int source) {
    int n = graph.length;
    int[] curDist = new int[n];
    boolean[] visited = new boolean[n];
Arrays.fill(curDist, Integer.MAX_VALUE);
curDist[source] = 0;
    while (true) {
        int from = -1, minDist = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            if (!visited[i] && curDist[i] < minDist) {
                minDist = curDist[i];
from = i;
}
            if (from == -1) return curDist;
            else {
                visited[from] = true;
                for (int to = 0; to < n; to++) {
                    curDist[to] = Math.min(curDist[to], graph[from][to] + curDist[from]);
}
            }
        }
    }
}
```

如果要求最短路径, 每次更新最短距离值时更新最短路径, 每次选取A点时使用A点的最短路径进行扩展

## Floyd算法

算法适合场景: 图中任意两点之间的最短路径

算法思想: 枚举每个点作为中点, 假设A->中点->B 的距离小于当前A->C, 更新A->C距离



```java
public int[][] floyd(int[][] graph) {
    int[][] dp = graph; //dp[i][j]表示i到j的最短距离, +INF 表示 不可达
int n = dp.length;
    for (int mid = 0; mid < n; mid++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid][j]);
    return dp;
}
```



# 图最小生成树算法

在图中找到能够让N个节点直接相连/间接相连的N-1个边使得N-1个边之和最小

## Prim算法

算法思想

```
1 : 从全部节点集合V中任选一个点移动集合S中
2 : 从没有选择的边中找到最短的边E, 满足start(E)属于S, end(E)属于V
3 : 将end(E)从V中移动到S, E加入已经选择的边
4 : 重复2,3直到 S包含全部节点 or  (2)中找不到E
```


## Kruskal算法
