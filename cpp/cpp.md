# 1. 基础知识

## 1. CPP 构建工具链

**_Cpp 的常见编译器有哪些?_**

```
>> GNU开源计划中的gcc/g++(Unix平台)

>> MSVC(Windows平台)
```

**_GNU 计划是什么?_**

```
GNU计划: 一个开源软件计划, 初衷是提供一系列自由的软件, GNU计划的开源软件需要遵循GPL开源协议

Tips: Linux gcc都属于GNU计划
```

**_make 和 Cmake 是什么?_**

```
>> make是GNU计划下的一个Cpp项目构建工具, 使用Makefile来配置构建过程

>> Cmake是跨平台的Cpp项目管理和构建工具, 使用CMakeLists.txt来配置构建过程
```

## 2. CPP 的编译

**_讲一下 cpp 源码到可执行程序的过程?_**

![1703998690633](image/cpp/1703998690633.png)

**_静态库和动态库各自的优点?_**

```
>> 静态库执行更快

>> 动态库更灵活, 可以在不重新编译主体程序的情况下替换掉动态库
```

**_编译器如何查找静态库?可执行程序如何查找动态库?_**

```
>> 静态库路径通过编译器参数/环境变量指定, 也可以直接将静态库文件放到项目文件夹(一般约定在\lib目录下)

>> 操作系统提供的动态库存放目录由环境变量指定, 也可以放在编译后的工程目录下
```

**_什么是预编译指令?_**

```
源码中以#开头的编译指令, 用于对源码进行预处理和编译器设置

tips: 常见的预编译指令有:
     #include: 将文件包含, 相当于直接复制过来
     #define: 定义标识符的替换字符
     #if #else #endif:  条件编译
     #pragma: 设置编译器参数
```

**_h 文件和 cpp 文件的区别?_**

```
>> h文件中仅声明标识符, 用于被其他文件#include

>> cpp文件中写标识符的具体实现, 不直接被#include
```

> 编译器只编译 cpp 文件, 从而间接包含 h 文件中的标识符定义, 同时编译阶段不需要知道标识符具体实现

**_如何避免头文件被循环 include 或头文件中重复声明标识符?_**

```
在头文件开头加上 #ifndef X_H #def X_H
结尾加上 #endif
```

## 3. CPP 的执行

**_cpp 程序的进程占用的内存的功能分区是怎样的?_**

```
代码区: 存放指令
常量区: 存储const变量/字面值常量
全局静态区: 存储全局变量/类的static变量
堆: 存储new/malloc创建的对象
栈: 存储函数的局部变量和返回地址
```

**_struct 结构体的变量在内存中是如何对齐的?_**

```
1. 一个成员变量的起始地址必须是变量类型的整数倍 (int的起始地址必须是4n)
2. struct总大小必须是最大成员变量的整数倍
3. struct的最小大小=1byte
```

**_指针类型在 32/64 位 CPU 中的大小分别是多少?_**

# 2. 语言特性

# 3. STL
