# 1. Redis简介

## 1. 术语

***常见的缓存实现方式有哪些?***

```
🌟 本地缓存 (如Guava Cache)

🌟 分布式缓存 (如Redis, Tair)
```

***Redis为什么快?***

```
🌟 使用内存存储数据, 内存io速度快
🌟 单线程避免了多线程的锁竞争和上下文切换
🌟 IO使用了IO多路复用
```

***Redis和Tair的区别?***

```
🌟 Redis使用内存, Tair使用内存和外存
🌟 Redis速度快但容量小, Tair容量大但速度


❗Tair适用于冷热数据显著的场景
```

***Redis事务能保证原子性和持久性吗?***

```
不能保证严格意义上的原子行和持久性:
🌟原子性: redis可以保证原子地执行一批指令, 但不支持回滚
🌟持久性: Redis采用RDB和AOF持久化机制保证持久性, 但默认不开启

❗使用multi exec开启和提交事务
```

***Redis的Pipeline可以保证原子性吗?***

```
不能, pipeline只能用于减少网络吞吐量(批量执行一批指令), 不保证执行这些指令期间不会执行其他指令
```

## 2.数据类型

***Redis五大常用数据类型是什么, 三大扩展类型是什么?***

```
基本类型: string, list, hash, set, zset(sorted set)

扩展类型: geospitial, hyperloglog(统计UV), bitmap
```

***Redis中哈希表扩容/缩容 是如何进行的?如何解决哈希冲突的?***

```
🌟 采用链表法解决哈希冲突
🌟 扩容缩容采用渐进式rehash, 一个set对象维护了两个长度不同的散列表, 
在对单个元素进行CRUD操作时会检查Load Factor是否过大/过小以决定是否将元素迁移到另一个散列表
```

***什么是Skip List?***

```
🌟跳表本质上是一个链表, 但链表的一个节点有多个不同level的指针, 每个level指针指向链表中下一个同level指针, 更高级的level的指针实质上构成了低级level指针的索引

🌟索引原理: 新插入的节点需要随机level(level从低到高概率呈指数级下降), 对跳表的基本操作的时间复杂度为log(N)
```

***GeoSpitial的邻近算法的原理?***

```
1️⃣ 使用GeoHash算法对经纬度进行编码
GeoHash算法: 将经纬度按照二分法进行分块(左半=0,右半=1,上半=0,下半=1), 然后按经纬度的01交替拼接组成一个数字, 数字越长确定的区域越小, 并且相领数字对应的区域也相邻
2️⃣ 将(key=GeoHash(经纬度), value=List<经纬度>)放入skip list中
3️⃣ 进行地理位置A邻近匹配时, 会先读取GeoHash(A)下的所有地理位置, 再读取改区域周围8个区域的节点位置(以此类推)
```

***Hyperloglog统计原理是什么?***


# 2. Redis单机

## 1. 内存淘汰策略

***什么是Redis内存淘汰策略? 淘汰策略有哪些?***

redis基于内存, 当内存不足时redis会淘汰部分键值对, 如何淘汰键值对就是淘汰策略, 常见的淘汰策略有:

```
* random: 随机淘汰
* ttl: 淘汰TTL最小
* lru: 根据LRU算法淘汰
* 禁止淘汰键值对, SET操作会报错
```

## 2 过期删除策略

***Redis中是如何删除过期键值对的?***

redis采用惰性删除和定期删除相结合的方式删除过期键

* 惰性删除: 当对键值对操作时, 如果检测到已经过期, 则删除
* 定期删除: 每隔一段时间删除过期字典中少量的过期键

## 3 持久化机制

***什么是AOF和RDB?***

* AOF是redis持久化机制之一, 当对数据库进行修改操作时, redis会往aof文件中追加修改指令, 当需要进行恢复时, 重新执行这些指令
* RDB时redis持久化机制之一, redis将数据库快照保存到rdb文件中, 每次启动时读取rdb文件进行恢复

> AOF优先级比RDB高, Redis服务器重启时优先使用AOF进行恢复;
> 
> 使用配置文件/命令行参数开启redis持久化

***持久化常用的指令有哪些?***

```
异步写入AOF文件: BGREWRITEAOF
异步写入RDB文件: BGSAVE
```

***AOF文件过大影响写入速度怎么办?***

redis会对aof文件进行重写, **重写时根据数据库快照中的键值对, 生成对应的写入指令**, 然后将这些写入指令添加到aof文件中

***AOF和RDB各自的优缺点?***

```
RBD: 
优点---恢复速度块
缺点---持久化间隔长, 可能丢失的数据多
AOF: 
优点---间隔短, 丢失的数据少
缺点---恢复速度慢
```

# 3. Redis集群

## 1. 主从架构

***redis主从架构的是怎样架构的?***

一个主从架构中有**一个主服务器(负责写请求), 多个从服务器(负责读请求), 和多个哨兵**, 哨兵负责监控主从服务器和其他哨兵的状态, 当主服务器挂掉时, 会从从服务器中重新选举出一个主服务器(**故障转移**)

![1683198718665](image/Redis设计与实现/1683198718665.png)

***Redis中主从服务器是如何进行数据同步的?***

```
* 从服务器/挂掉后重启的主服务器 在第一次连上主服务器后全量复制主服务器的数据

* 随后主服务器被写入数据后使用增量复制的方式异步复制到从服务器
```

***Redis中主从服务器数据一致性问题是什么 怎么解决?***

主从异步复制导致的问题:

```
* 异步复制丢失问题: 主节点被写入数据后来不及同步到从节点就宕机导致写入的数据丢失



* 脑裂问题: 主节点由于网络分区问题可以被访问, 但主节点连接不到从节点群, 网络恢复后主节点中的新写入数据由于进行全量复制导致丢失
```

通过参数设置 `y秒内至少有x个从节点` 进行了主从同步来减少丢失的数据

```
min-slaves-to-write x
min-slaves-max-lag y
```

## 2. 集群

***什么是redis集群?***

一个redis集群中有多个主节点, 主节点之间会互相保存数据副本, 对其中一个主节点发起的请求会被路由到集群中特定的节点

![1691739298560](image/redis/1691739298560.png)

***什么是一致性hash算法?***

一致性hash算法适用于分布式系统中, 相较于传统的hash算法, **避免了节点故障时数据的大量迁移**

```
一致性hash算法的哈希空间是一个环, 节点和数据都会映射到环中的虚拟node上, 当一个节点发生故障时, 数据会被迁移到患上最近的节点上
```

redis采用slot的机制, **一个slot对应一致性hash算法中虚拟hash环上的一个node**,  一个redis实例负责特定范围的slot

# 4. 缓存实践

## 1. 缓存穿透, 击穿, 雪崩

***什么是缓存穿透, 缓存击穿, 缓存雪崩, 如何解决?***

缓存穿透

```
大量请求访问数据库中不存在的数据, 导致请求穿透缓存层到持久层
解决方法: 缓存空值/bloomFilter
```

缓存击穿

```
大量请求同时访问过期的缓存, 导致请求击穿到持久层
解决方法: 在热点数据过期前提前加载到缓存中/使用互斥锁保证同时只有一个相同的请求访问持久层
```

缓存雪崩

```
短暂时间内大量缓存失效导致请求大量到达持久层
解决方法: 过期时间尽量区分开/使用多级缓存
```

***什么是bloomFilter, 如何减小bloomfilter的误判率?***

用于判断数据一定不存在的一种数据结构, **使用一个bitmap和多个hash函数**, 对于一个数据, 通过多个hash函数映射到bitmap上不同位置上的1, 如果查找时发现某一位不为1则肯定不存在该数据

**提高bitmap大小**可以减少误判率

***什么是双key缓存热点数据, 相对与单key的优点?***

```
双key缓存数据是指使用一个key缓存过期时间(该key的过期时间短), 另一个key缓存数据(过期时间长)

* 查询数据时, 先查询过期时间key, 如果存在则查询热点数据key
* 如果不存在, 重新写入过期时间key, 随后访问数据库更新热点数据(包括其过期时间)

相对于单key缓存热点数据, 避免了缓存击穿问题
```

## 2. 缓存一致性问题

***什么是缓存一致性?***

```
当对数据库中数据进行修改后, 缓存和数据库中的数据无法实现事务上的一致性, 这就是缓存一致性问题
```

***如何确保缓存一致性?***

```
如果对一致性要求不高, 只需要设置redis缓存的过期时间

如果对一致性要求较高,  可以采用先更新数据库, 再删除缓存 + (延迟双删)
```

***为什么采用删除缓存而不是更新缓存?***

```
更新操作可能会延迟导致缓存中的是脏数据
```

## 3. 分布式锁

***如何使用Redis指令实现分布式锁?***

```
加锁LUA脚本:
SETNX(LockName, IP_ThreadId, ExpireTime)


解锁LUA脚本:
CompareAndDelete(LockName, IP_ThreadId)

Q: 为什么要将value设置为IP_ThreadId?
A: 防止超时时解锁了其他线程的锁

Tip: 可以使用开源库Redisson作为分布式锁实现
```

***为什么可以通过LUA脚本保证操作的"原子性"?***

```
Redis采用单线程模型, LUA脚本执行时不会有其他Redis命令执行
❗如果一个Lua脚本中同时操作了多个key会导致cross-slot问题不能保证原子性, 所以当Lua脚本中操作了多个key时会导致执行失败
```

***怎么解决线程执行时间超时导致锁超时问题?***

```
使用守护线程在超时前更新超时时间实现自动续约
```

***Redis主从异步复制为什么会导致分布式锁出现问题?***

```
如果在加锁成功后主节点立刻宕机, 来不及将数据同步给从节点. 此时可能导致锁被另一个线程获取

解决方法: 使用RedLock算法, 使用多个Redis主节点, 只有当半数以上主节点SETNX成功才算加锁成功
```

***Redis如何实现可重入锁和公平锁?*** 

```
🌟可重入锁: 将加锁操作和解锁操作改为: 
加锁: IncrementIfNX(LockName, IP_ThreadId, ExpireTime) 
解锁: CompareAndDecrement(LockName, IP_ThreadId, ExpireTime)


🌟公平锁: 加锁前维护一个Redis List, 只有IP_ThreadId在列表头时才加锁成功
```

***使用Zookeeper实现分布式锁和使用Redis实现分布式锁有什么差异?***

```
Redis: 并发性能更好
Zookeeper: 安全性更好(Redis主从是异步复制, 可能导致锁失效; Zookeeper采用分布式一致性协议)
```

## 4. 业务实现

***如何使用redis实现排行榜功能?***

使用 `zset` 实现排行榜, **用户id作为key, 排序字段映射为score**

可以将多个排序字段映射为score不同权重位上实现多字段排序

***如何使用redis实现文章点赞计数?***

* 使用 `hash `存储文章点赞信息 `[uid, 点赞次数]`, 点赞时 `increby(1)`
* 使用 `set`存储文章点赞信息 `{uid1, uid2}`

***如何使用redis统计UV?***

精确统计使用 `set`

不需要精确统计使用 `hyperloglog`

***如何使用redis实现附近的人的功能?***

使用 `Geospatial`

***如何使用redis实现短信验证码/会话管理功能?***

redis保存键值对:  `[uid, token/code]` **并设置过期时间**

***如何使用redis实现分布式全局唯一ID?***

使用指令:  `INCR AND GET`

***如何redis实现分布式接口限流?***

使用 `zset` 作为滑动窗口 或者 使用 `list` 作为令牌桶

***如何使用redis实现接口幂等性?***

当请求成功响应后向redis中保存 `[api_id + uid + 请求参数hash值, 请求次数+1] ` 并设置一定的过期时间, 新请求需要确保redis中无相关key/请求次数小于限制次数

***大Key如何删除?***

```
对于value占用内存特别大的键值对, 需要分批次删除, 避免一次性删除导致redis阻塞请求
```
