# 1. mysql简介

## 1. 关系型数据库理论

***关系型数据库的约束类型有哪些?***

```
主键约束Primary Key
非空约束Not Null
唯一约束Unique
外键约束Foreign Key
默认约束Default
检查约束Check
```

***关系型数据库的三范式指的是什么, 必须要遵循三范式吗?***

```
1NF: 属性是原子的
2NF: 非主键完全依赖于主键
3NF: 非主键之间不存在传递性依赖
```

***什么是视图, 什么是存储过程?***

视图是使用QL语句定义的一张逻辑上的表, 没有物理表对应

```sql
-- 创建视图
CREATE VIEW view_name AS
SELECT * FROM table WHERE ...
```

存储过程相当于一个数据库的函数

```sql
-- 创建存储过程
CREATE PROCEDURE get_customer_orders(IN customer_id INT)
BEGIN
    SELECT order_id, order_date, total_amount
    FROM orders
    WHERE customer_id = customer_id;
END;
```

***内连接, 左外连接, 全外连接的区别?***

内连接和外连接的区别: 外连接中, 即使一张表中有一条行记录匹配不到另一张表中的任何一行, 也会保留一条值为null的连接记录

左外连接至少保留左边的表中的一行, 全外连接左表和右表都至少保留一行

***count(`*`**)**和count(1)和count(字段)的区别?***

count(字段)当字段为null时不会计数

count(*)和count(1)都可以统计行数, 但一般来说存储引擎会对count(`*`)进行性能上的优化

***深分页问题如何解决?***

* 使用缓存, 将分页查询结果缓存
* 使用一个游标字段, 字段值随分页增加递增, 每次获取前一页的最后一个值X, 用来作为条件>X从而实现走索引

***drop truncate delete的区别?***

* delete遵循事务机制(其他两个不是事务), 作用是条件删除表的记录
* drop直接删除表(包括表的结构), truncate删除表所有记录, 不删除表

***union 和 union all的区别?***

union会去重, union all不会

## 2. mysql server架构

***mysql服务器采用分层架构, 具体怎么分的?***

```
从上到下分为:
连接管理层: 进行连接的安全验证和连接池管理
解析优化层: 查询缓存, 进行词法分析, 语法解析, 通过SQL处理器, 查询优化器生成查询计划
存储引擎层: 执行查询
文件系统: 操作系统的文件系统, 保存了表的物理结果
```

![1691131088320](image/mysql/1691131088320.png)

## 3. 存储引擎

***常用的存储引擎有哪些, 它们之间有哪些区别?***

常用的存储引擎: Innodb, MyISAM, Memory

Innodb和MyISAM的区别:

```
* Innodb支持事务, MyISAM不支持
* Innodb支持行锁级别的锁粒度, MyISAM的锁粒度级别为表锁
* Innodb支持外键, MyISAM不支持
* Innodb使用聚簇索引, MyISAM使用非聚簇索引
```

Memory是使用内存的存储引擎

***如何使用SQL语句设置/切换表的存储引擎?***

```sql
ALTER TABLE table_name ENGINE = MYISAM

CREATE TABLE table_name(
 ...
) ENGINE = InnoDB
```

## 4. mysql server调控

***如何对mysql服务器进行个性化设置?***

通过设置系统变量来对服务器进行设置, 系统变量可以通过配置文件设置, 也可以通过指令 `SET GLOBAL 变量名 = 值`设置

可以通过 `SHOW VARIABLES LIKE 'xxx'` 查看系统变量的值

***如何查看mysql服务器运行状态?***

通过指令查看状态变量 `SHOW STATUS LIKE 'xxx'`

***表的字符集使用utfmb3和utfmb4有什么区别?***

uftmb3是utf-8的子集, 最大字符编码长度为3字节, **不包含表情符号**

utfmb4是完整的utf-8编码

# 2. Innodb

## 1. 表的存储

***Innodb中表是如何存储的?***

表存储在文件系统中, 读写表时先将表文件读取到内存缓冲池中(以16KB大小的页为基本单位), 读写完成后再刷新到文件中

***一个页中行记录是如何存储的?, 如何进行查找的?***

一个页中的行记录使用**单链表**连接, 并且链表至少有一个最大记录和最小记录

查找记录时**对单链表的目录进行二分查找,** 快速定位到要查找的记录所在的slot

![1691476779977](image/mysql/1691476779977.png)

## 2. 记录行的存储

***Innodb中行格式有哪些?***

常见的行格式: Compact, Dynamic, Compressed

***简单说一下你知道的行格式具体是怎样的?***

一行记录由: `变长字段长度列表+null值列表+记录头+记录数据`  组成

其中null值列表使用一个bit位记录一个字段是否位null

![1691475887978](image/mysql/1691475887978.png)

***记录头中记录了什么信息?***

* **trx_id:** 事务id, 用于mvcc
* **roll_ptr**: 用于mvcc
* **row_id**: 行id, 自动生成

***如果一行记录太长了, 导致一个页放不下, 如何存储?***

对于过长的字段(如varchar最大字节长度为65535), 在原本存储字段值的地方存储一个**溢出指针**, 指向存放溢出数据的页

## 3. 索引

***Innodb为什么使用B+树作为索引, 而不使用B树, AVL?***

* B+树相较于B树支持范围查找(叶节点使用双向链表连接)
* B+树相较于AVL来说, 树的高度更小, 磁盘IO的次数更少

***索引的分类有哪些?, 什么是回表?***

```
* 聚簇索引: 完整的记录在B+树索引的叶节点上
* 二级索引: 索引的叶节点只保存记录的主键, 如果需要查找完整的记录需要回到聚簇索引中查找(回表)
* 联合索引: 多个字段按照字典序排序, 构成一个索引
```

***什么是最左匹配原则?***

要使用联合索引, 作为条件的字段必须覆盖联合索引的左前缀

***索引B+树为什么高度一般不超过3层?***

页的大小为16KB, 假设一个页存储1000条记录, 3层能够存储10^9条记录, 这个数量一般来说已经足够

***索引什么情况下会失效?***

* 索引字段进行计算时发生了类型转化 / 使用了函数转换
* 联合索引没有按照最左匹配原则
* 特殊的查询条件, 如NOT NULL, !=, like+"%"通配符作为前缀

***什么字段适合建立索引, 建立索引有哪些技巧, 使用索引有哪些注意事项?***

* 重复度小的字段适合作为索引
* 频繁作为查询条件和排序条件和分组条件的字段适合作为索引
* 不要建立过多的索引
* 表太小也不要建立索引

***为什么建议使用自增主键?***

避免新增记录导致的频繁的**页分裂**

# 3. 事务和锁

## 1. 事务简介

***什么是事务, 事务的ACID特性的是什么?***

事务通俗的讲就是一段**要么全部执行, 要么全部不执行**的SQL

```
A: 原子性: 要么全部执行, 要么全部不执行
C: 一致性: 事务执行前后数据库保持一致性
I: 隔离性: 不同事务之间的执行互不影响
D: 持久性: 事务对数据库的影响是永久的
```

***事务隔离级别有哪些, 每个隔离级别会导致的问题?***

```
RU:  一个事务内可以读取到还未提交的事务进行的更改, 会有脏读问题
RC: 一个事务内只能读取到已经提交的事务的更改, 会有不可重复读问题
RR(innodb默认隔离级别):  一个事务期间数据的值在事务开始和结束时一致, 会有幻读问题
SERIAL: 事务之间串行执行
```

## 2. MVCC

***RC, RR隔离级别下是如何进行快照读的/MVCC原理?***

每条行记录中的记录头中包含**roll_ptr指针和trx_id**, 由roll_ptr指针构成了一个版本链(旧记录存储在**undo log**中), 每次查询的时候会生成一个ReadView, ReadView定义了当前事务可见的记录的trx_id的范围, 然后事务顺着版本链查找记录, 如果记录不可见则跳过

## 3. 锁

***锁的分类有哪些, CRUD各自会加什么锁?***

锁分类:

```
* 互斥锁 SELECT ... FOR UPDATE
* 共享锁 SELECT ... IN SHARE MODE

* 行锁
* 表锁
* 表意向锁: 申请行锁前需要先申请表意向锁
* 自增锁: 自增主键递增时需要申请自增锁

* 记录锁: 修改记录前先申请记录锁
* 间隙锁: 插入数据前需要申请间隙锁
* 临键锁: 记录锁 + 记录旁边的间隙锁
* 隐式锁
```

* SELECT: 互斥锁/共享锁
* DELETE: 互斥锁
* UPDATE: 先加互斥锁(读), 在按照情况加INSERT对应锁(修改了主键的情况)
* INSERT: 加插入意向锁, 隐式锁(使用事务id实现)

## 4. 日志

***Mysql中有哪些日志?各种日志的作用是什么?***

redo日志

```
用于保证事务的持久性, 当把数据写入缓冲池中的页后, 会将更改也写入redo log
```

undo日志

```
用来保证事务的原子性, 也用来支持MVCC, 如果对页面写入, 会在undo log 中记录 
```

bin日志

```
用于备份和主从复制, bin log中会记录二进制的数据库中的数据
```

***什么是二阶段提交, 为什么要二阶段提交?***

`写入redo log(准备阶段) => 写入bin log => 再写入redo log(提交)`

2PC避免了数据库崩溃导致的问题

# 4. 调优相关

## 1. Explain

***EXPLAIN可以做什么? 结果中重要的列有哪些?***

explain+DQL语句可以查看执行计划, 执行计划中重要的字段:

```
* key: 使用到的索引
* type: 查询方式
* key_len: 使用到的索引的长度
* rows: 预估行数
* Extra: 有助于查询优化的额外信息
* table: 查询的哪个表
```

***type有哪些?***

```
* 全表扫描: ALL
* 索引全扫描: Index
* 索引范围扫描: Range
* 索引的等值查询: eq_ref
* 不适用索引页不扫描表: NULL
```

## 2. 分库分表

***什么是雪花算法, 为什么使用雪花算法而不是表的自增ID?***

雪花算法生成的ID结构: `1个标志位+41位时间戳+10位机器码+12位序列号`

```
使用雪花算法的原因: 
* 分库分表导致表的自增id可能相同, 使用雪花算法可以生成全局唯一id且这些id大致递增, 避免B+树索引频繁的节点分裂

* 即使不是分库分表, 单一表中使用自增id会导致表锁, 高并发下性能差
```

***分库分表有哪些方式?***

分为垂直分表和水平分表, 垂直分表将一个表中不常使用的字段和常用字段拆分到不同表中, 水平分表将一张表中的记录拆分到不同表当中

## 3. 主从数据库

***什么是主从架构, mysql中如何实现主从同步的?***

主服务器负责写入, 通过同步机制同步到从服务器, 从服务器负责响应读请求

mysql中通过binlog实现主从同步
