# SQL语句

# 理论

## 范式

```
1NF: 属性是原子的, 不可再分
2NF: 非主键可以由主键/联合主键唯一确定
3NF: 非主键不能依赖于其他非主键
```

## 约束

```
主键约束: 唯一且非空
唯一约束: 唯一
外键约束: 必须是其他表中的主键
默认约束: 默认值
检查约束: 人为定义字段值需要符合的条件
非空约束: not null
```

## 引擎

```
innodb: 支持事务和崩溃恢复, 行锁+间隙锁+主键聚簇索引+MVCC+默认隔离级别可重复读
MyISAM: 不支持事务和崩溃恢复, 表锁+主键二级索引, 适合只读数据库索引 
```

其他引擎

```
CSV: 可以将一个csv文件当作一个数据库表使用
```

## 数据类型

字符串varchar/char使用编码**utf8mb4**

精确数字使用**decimal**

datetime和timestamp

```
datetime存储固定的时间刻 YYYY/MM/DD HH:mm:ss
timestamp存储当前时区下对应的时间戳, 查询时返回当前时区对应的datetime
```

## 查询优化

如果查询过慢如何解决?

```
1. 给查询用到的字段添加索引
2. 如果表过大尝试分库分表
3. 如果Mysql服务器压力过大尝试主从架构
4. 将大查询sql拆分为多个小查询
```

如何分析慢sql?

```
explain select ...
```

百万级别的表如何批量删除?

```
先删除索引, 再批量删除记录, 再重建索引
```

## 分库分表

分为水平分表和垂直分表

```
水平分库分表: 需要根据主键或特定字段将不同的记录分到不同的表中
垂直分库分表: 需要将不常用的字段拆分到其他表中, 常用的字段单独一张表, 避免记录太大跨页造成的额外i/o
```

水平分表后可能遇到的问题

```
主键不能使用自增主键, 常用雪花算法(64bits做主键, 时间+机器id+序列号)
事务需要使用分布式锁
```

## MySQL架构

MySQL架构?

```
数据库连接池: 便于连接的复用和管理
查询缓存
词法分析器,语法分析器
查询优化器
存储引擎
```

mysql连接过程?

```
SSL协议+TCP协议
```

## 主从服务器

主从架构

```
主服务器负责写, 从服务器负责读
主服务器通过binlog记录修改操作, 并将binlog发送给从服务器, 从服务器会将binlog中的内容写入自己的数据库中 
```

# 索引

## 索引创建

```
1. create table时声明索引
2. creat index .. on ..
3. alter table ... add index ..
```

## 索引优缺点

```
优点: 查询更快
缺点: 需要花费额外的空间和时间来维护索引
```

## 索引类型

```
联合索引: 多个字段按字典序排序的索引
唯一索引: 索引字段的值必须唯一且值可以为null(主键的索引是一种特殊的唯一索引)
普通索引: 索引字段值不一定唯一, 需要给字段添加额外主键然后按字典序进行比较
全文索引: 分词+倒排索引
聚簇索引: 索引结构中保存每一行的数据, 不需要额外回表, 指innodb中的主键索引
二级索引: 非聚簇索引
```

## 索引失效场景

```
1. 索引列参与了算术运算/函数运算/类型发生了隐式转换
2. 特殊的查询条件如!=/or/模糊查询+通配符
3. 联合索引不满足最左匹配原则
```

## 适合索引的场景

```
1. 唯一性的字段(如主键)
2. 经常用作查询条件的字段(where/group by/order by/join on)
```

## 不适合索引的场合

```
1. 字段值重复度高(如性别)的字段
2. 数据量少的表
3. 修改比较频繁, 但查询比较少的表
```

## 索引与B+树

为什么不索引B树, BST, AVL做索引?

```
B树不适合顺序检索/范围检索
BST和AVL高度太高, 对应的IO次数过多, AVL还要频繁旋转
```

为什么不使用Hash做索引?

```
模糊查询用不到Hash索引
不支持顺序检索/范围检索
```

## 回表与索引覆盖

索引覆盖

```
要查询的字段都在索引中, 不需要到聚簇索引中查找, 称为索引覆盖
```

回表

```
要查询的字段部分不在索引中, 需要获得主键后在到主键聚簇索引中查找字段
```

# 事务

## ACID

acid

```
原子性: 要么不做, 要么全部做
一致性: 事务不论失败还是成功 数据的一致性不会被破坏(转账的话总金额不变)
独立性: 并发事务之间需要设置隔离级别下确保不会相互影响
持久性: 事务对数据库的修改是永久的
```

acid保障机制

```
原子性: undo log(事务回滚时撤销)
独立性: 锁+MVCC
持久性: redo log(系统崩溃后重做)
```

## 隔离级别

```
读未提交 事务可以看见未提交的数据(脏读)
读已提交 只有已经提交的修改对事务可见(不可重复读)
可重复读 通过对已经读取的数据进行加锁防止其他事务修改(幻读)
可串行化 事务之间并行执行
```

MySQL默认级别可重复读, 使用间隙锁解决幻读问题

## 悲观锁和乐观锁

悲观锁

```
获取锁之后不允许其他事务再获取该锁, 适合并发竞争较多的场景
```

乐观锁

```
获取锁之后其他事务可以获取该锁, 在写入数据时检查版本号是否与读的时候一致, 不一致进行自旋(回滚重试)
乐观锁除了使用版本号还可以使用CAS(CAS比较的是期待值和现在的值)
```

## Innodb中锁的种类

共享锁(S), 排他锁(X)

```
写锁共享, 读锁互斥
共享锁: select ... lock in share mod
排他锁: select * from ... for update
```

间隙锁

```
在两条记录之间的锁, 获取间隙锁后其他事务不能在间隙间插入
```

意向锁(IS, IX)

```
表级别的锁, 在申请S锁之前要先申请IS锁, 申请X锁之前先申请IX锁
用于记录表中某一行是否被持有S锁/X锁, 避免轮询
```

## 死锁

Mysql中发生了死锁如何排查

```
查看日志: show engine innodb status
查看死锁sql
分析加锁情况
```

## MVCC

多版本并发控制

```
每个记录维护一个特定版本的冗余数据, 一个事务对应一个版本, 读取时数据的快照版本
MVCC可以实现读写不互斥, 
```


# 日志

## redo log

redo log 是一个物理日志, 记录了数据页变化前的数据和变化后的数据, 保证了事务的持久性

```
当事务修改buffer pool 中的缓存页时, 需要写入redo log buffer中, redo log buffer在事务提交/定时刷新时会刷新到磁盘中
```

为什么不直接将数据写入磁盘?

```
一般数据的修改量很少, 直接将一个页写入代价大
redo log适用append方式写入快
```


## undo log 

undo log 是一个逻辑日志, 记录了更新Sql的逆向Sql, 保证事务的原子性, 实现MVCC
