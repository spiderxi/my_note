# 1. 计算机系统概述

## 1.1 冯诺依曼体系结构

![1679055565216](image/计算机组成原理/1679055565216.png)

核心思想: 存储程序, 顺序读取指令并执行

* 存储器

![1679055645095](image/计算机组成原理/1679055645095.png)

* 运算器: 处理加减乘除 逻辑运算 位运算

![1679055709435](image/计算机组成原理/1679055709435.png)

**寄存器:** 存储临时计算结果和操作数, 现代计算机有上百个寄存器, 统称**通用寄存器组**

**累加器:** 存储中间结果和最终结果

**机器字长:** 一次运算的二进制数的长度, 一般为32bit/64bit

* 控制器

  ![1679056130449](image/计算机组成原理/1679056130449.png)

状态寄存器: 存储计算机运行状态

时序电路: 产生时序信号, 让指令有序执行

* 总线: 系统各个部分通信使用, 分为地址线 数据线 控制线
  ![1679056300248](image/计算机组成原理/1679056300248.png)

同一时间只能有一个设备向总线发送消息, 所有设备都可以接收消息

## 1.2 机器性能指标

* 机器字长

```
CPU一次运算中二进制数据的长度(单位bit)
```

* 主存容量

```
存储器的一个存储单元容量一般为1Byte
主存的容量1PB = 2^10 TB = 2^20 GB = 2^30 MB = 2^40 KB = 2^50 B
所以1PB至少需要50根地址线
```

* 时钟周期/主频

```
时钟周期是CPU内部时序电路产生的脉冲的周期, 是计算机内部最小的时间间隔
T = 1ns 的CPU主频是 1GHz
1GHz = 1000MHz = 10^6 KHz = 10^9 Hz
```

* CPI/IPC

```
CPI: 每条指令执行的时钟周期数 IPC: 1/CPI
!!!由于指令流水线和多核, 现代计算机的CPI < 1
```

* MIPS/MFLOPS

```
MIPS: 每秒执行指令个数(百万)
MFLOPS: 每秒执行浮点数指令个数(百万)
```

## 1.3 计算机系统层次

![1679059063510](image/计算机组成原理/1679059063510.png)

# 2. 数据的编码和表示

## 2.1 原码 反码

* 原码

```
第一位为符号位 0:+  1:-
后面跟二进制的数值如+7=0111 -7=1111
```

* 反码

```
正数的反码和原码相同
负数的反码 = 原码数值位取反
```

> 反码相较于原码加减运算更容易实现, 但都不如补码, 现代计算机使用补码

## 2.2 补码

***补码的加减等于加减的补码, 加减时符号位看作一个数值位加减***

![1679068586237](image/计算机组成原理/1679068586237.png)

![1679068619620](image/计算机组成原理/1679068619620.png)

原码如何转成补码?

```
符号位=0, 原码就是补码

符号位=1, 其他位全0对应最小值(-2^(n-1)), 否则数值位取反后, 数值位+1获得补码
```

## 2.3 移码

![1679060794492](image/计算机组成原理/1679060794492.png)

将真值+偏移量(bias, 一般是2^n)获得的无符号整数就是移码(真值的最小值对应0), 移码用于比较大小

```
+1001 -> 11001 (+2^5)
-1111 -> 00001 (+2^5)  
```

## 2.4 定点数和浮点数

定点小数溢出会损失精度

![1679061178102](image/计算机组成原理/1679061178102.png)

IEEE float结构

![1679061516450](image/计算机组成原理/1679061516450.png)

E = 真值(-126到127之间) + 127

![1679061788474](image/计算机组成原理/1679061788474.png)

> 如0.1 0.2 0.3这样的数在使用浮点数表示时尾数会出现循环, 最终会造成很小误差, 但误差积累可能造成严重后果:
>
> 0.1+0.1+0.1-0.3 != 0

## 2.5 ASCII GBK Unicode

```
ASCII 1个字节对应一个字符
GBK 两个字节对应一个汉字
UTF-16: 2个字节对应一个字符
UTF-8: 2-3个字节对应一个字符, 兼容ASCII
UTF-32: 4个字节对应一个字符
```

## 2.6 校验码

码距: 一个编码集中两个不同编码的海明距离最小值

码距和纠错检错能力关系

![1679064792856](image/计算机组成原理/1679064792856.png)

常用的校验码方式

```
奇偶校验码
CRC循环冗余校验码
海明校验码
```

## 2.7. 运算器组成

运算器组成

```
1. ALU 
2. FLU
3. 通用寄存器组: 存储堆栈指针 作为变址寄存器和状态寄存器 存储运算的中间结果

```

ALU的输出

![1679220425092](image/计算机组成原理/1679220425092.png)

## 2.8 浮点数加减运算步骤

```
1. 对阶: 阶数小的变成阶数大的, 尾数右移n位
2. 尾数相加减(双符号位判断溢出)
3. 如果溢出后需要需要移动尾数并改变阶数
4. 检查阶数是否上溢出/下溢出
```

# 3. 存储系统

## 3.1 存储系统层次

![1679082420713](image/计算机组成原理/1679082420713.png)

## 3.2 主存

存储器分类

```
RAM: 访问任何地址的时间开销基本相同, 半导体RAM断电易失
ROM: 只读存储器, 断电不会丢失数据, 如CD-ROM DVD-ROM
SRAM: 基本存储单元是门电路组成的稳态电路, 存储速度快, 用于cache
DRAM: 基本存储单元是电容, 需要定时刷新, 存储速度比SRAM慢, 用于主存
```

主存地址类型

```
字节地址: 一个地址对应一个字节
半字地址: 一个地址对应机器字长/2
字地址: 一个地址对应1个机器字长
```

数据存储方式

```
小端存储(little-endian): 小的地址对应的字节存储数据的低位
大端存储(big-endian): 小的地址对应的字节存储数据的高位
0x87654321的小端存储21 43 65 87 大端存储 87 65 43 21

//现代处理器多采用小端存储
```

对齐存储

![1679083365691](image/计算机组成原理/1679083365691.png)

```
对齐后浪费了存储空间但提高了访问效率, 主流编译器会对数据结构进行对齐
```

## 3.3 DRAM的刷新

![1679119964634](image/计算机组成原理/1679119964634.png)

```
集中刷新会导致一段时间内存储器不可用
分散刷新在每个读写周期后面的时间进行刷新
异步刷新在每个时间段结束时进行刷新
```

## 3.4 存储的扩展

* 位扩展: 扩展数据总线的宽度

  ![1679128772329](image/计算机组成原理/1679128772329.png)
* 字扩展: 扩展地址总线的宽度

  ![1679128817415](image/计算机组成原理/1679128817415.png)
* 字位扩展

  ![1679128857244](image/计算机组成原理/1679128857244.png)

## 3.5 多体交叉并行存储

![1679129036718](image/计算机组成原理/1679129036718.png)

由于程序访问的局部性原理, 4个存储体可以并行读取数据, 并行读取的时序如下

![1679129280264](image/计算机组成原理/1679129280264.png)

## 3.6 Cache

使用Cache原因

```
SRAM价格太贵, 使用Cache作为CPU寄存器和主存之间的缓存
程序访问的局部性原理: 
  1. 时间局部指程序访问过的存储位置在接下来的时间很可能再次访问
  2. 空间局部指程序访问过的存储位置附近的位置很可能被访问
```

## 3.7 主存和Cache的映射方式

***主存和Cache映射方式有哪些?***

1. 全相联映射

```
全相映射: 

一个主存数据块 -> n个Cache行
每个cache行需要额外存储主存块的id
```

![1679159480517](image/计算机组成原理/1679159480517.png)

2. 直接相联映射

```
主存中多个连续的数据块称为一个区, 区的大小和cache大小相当
一个区内, 一个数据块对应序号相同的一个cache行

每个cache行额外存储主存的区id
```

![1679159736101](image/计算机组成原理/1679159736101.png)

3. 组相联映射

```
一个主存数据区内, 一个数据块对应一个cache组中的一行
cache保存行需要额外数据块的区id
```

![1679161402476](image/计算机组成原理/1679161402476.png)

## 3.8 cache替换算法

1. FIFO

```
需要每个cache行记录次数, 每次加载一个新的cache行时其他行的次数+1, 替换次数最高的一行
```

2. LFU(最少使用)

```
需要额外记录命中次数, 每个命中一个cache行时次数+1, 替换次数最小的
```

3. LRU(最近最少使用)

```
需要额外记录命中间隔, 每个命中一个cache行时间隔=0, 其他间隔+1, 替换间隔最长的
```

4. 随机替换

```
当cache可替换行较多时性能很好
```

## 3.9 写策略

1. 写回(Write Bacck)

```
设置一个脏位, 当cache行被淘汰时如果被写过则需要刷新主存中的数据
```

2. 写穿(Write through)

```
每当要写入cache行时, 将cache行对应的主存也一起写
```

## 3.10 虚拟存储器原理

根据局部性原理从外村只加载部分数据和程序到主存中

程序内部使用虚拟地址时, 操作系统或硬件将虚拟存储器地址**通过表的方式转换成主存地址**, 当主存中没有数据时会发生缺页中断加载缺页

![1679162965877](image/计算机组成原理/1679162965877.png)



## 3.11 页式存储器

![1679163152448](image/计算机组成原理/1679163152448.png)

主存和辅存空间都被划分成多个相同大小的页(一般是4KB)

```
虚拟地址到物理地址的转换过程如图
每个进程都有一个虚拟空间, 所以都单独有一个页表
页表采用虚拟页号作为索引, 虚拟页有多少个, 页表项就有多少个
```

![1679163447700](image/计算机组成原理/1679163447700.png)

![1679163574573](image/计算机组成原理/1679163574573.png)

> 如果需要的页在主存中缺失, 会触发操作系统内核的缺页异常处理程序, 把需要的页从辅存调入主存, 如果主存的页都被使用需要替换页, 还要看情况判断是否把被替换的页直接丢弃或是写回辅存

TLB: 容量较小的cache, 缓存常用的虚拟页号和物理页号的对应关系, 访问速度比一般cache更快

![1679164662937](image/计算机组成原理/1679164662937.png)

# 4. 指令系统

## 4.1 指令介绍

指令的分类和对应关系

![1679168738172](image/计算机组成原理/1679168738172.png)

机器指令的组成

![1679168760313](image/计算机组成原理/1679168760313.png)

```
如何通过地址码找到操作数称为寻址方式, 不同操作码对应不同寻址方式
```

## 4.2 寻址方式

指令寻址方式分为顺序和跳跃寻址

![1679214876048](image/计算机组成原理/1679214876048.png)

**操作数寻址方式**

1. 立即寻址 直接寻址 寄存器寻址

![1679214962296](image/计算机组成原理/1679214962296.png)

2. 间接寻址, 寄存器间接寻址

![1679215025286](image/计算机组成原理/1679215025286.png)![1679215033864](image/计算机组成原理/1679215033864.png)

3. 相对寻址 变址寻址 基址寻址

![1679215137318](image/计算机组成原理/1679215137318.png)![1679215146173](image/计算机组成原理/1679215146173.png)

```
基址寻址方式的基址寄存器默认, 不需要寄存器号
基址寻址方式常用于多道程序的操作系统的一个程序的地址重定位
```

5. 存储器栈寻址 寄存器栈寻址

![1679216376268](image/计算机组成原理/1679216376268.png)

![1679216393296](image/计算机组成原理/1679216393296.png)

## 4.3 RISC和CISC

```
CISC=复杂指令集, 指令数>200, Intel X86架构采用CISC
RISC=精简指令集, 这种指令集的CPU寄存器数量多, ARM架构采用RISC
```

# 5. CPU

## 5.1 CPU结构

![1679221038886](image/计算机组成原理/1679221038886.png)

## 5.2 异常和中断

分类

```
Falut: 指令造成的错误(/0)
Abort: 硬件出错导致终止程序(总线校验码出错)
Trap: 指令显示触发异常(system call)
Interrupt: 鼠标点击事件, 申请CPU中断当前程序, 
```

处理流程

```
关中断->保存断点->异常处理程序
```
